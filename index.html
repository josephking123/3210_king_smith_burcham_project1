<!DOCTYPE html>
<html>
<head>
    <title>CSC3210 Puzzle Pandamonium</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="1200" height="900"></canvas>

<script type="module">
import * as THREE from 'three'; // Imports the THREE.js library

// sets up the scene
const canvas = document.getElementById('myCanvas');
const scene = new THREE.Scene();
// creates the perspective camera
const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 3000);
camera.position.z = 1500; // how far back the camera is to the canvas
camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0)); // looks at origin
scene.add(camera); // adds the camera to the scene

// WebGL render
const renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
renderer.setClearColor(0xFFFFFF); // Sets background color to white
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

// Define vertices of the octagon
const octagonVertices = [
    new THREE.Vector2(-250, -125), //0
    new THREE.Vector2(-125, -250), //1
    new THREE.Vector2(125, -250), //2
    new THREE.Vector2(250, -125), //3
    new THREE.Vector2(250, 125), //4
    new THREE.Vector2(125, 250), //5
    new THREE.Vector2(-125, 250), //6
    new THREE.Vector2(-250, 125) //7
];

// Define internal vertices
const internalVertices = [
    new THREE.Vector2(0, 0), 
    new THREE.Vector2(-50, 175)
];

// Define triangles using octagon and internal vertices
const predefinedTriangles = [
    [octagonVertices[1], internalVertices[0], octagonVertices[0]], //triangle 1
    [octagonVertices[2], internalVertices[0], octagonVertices[1]], //triangle 2
    [octagonVertices[3], internalVertices[0], octagonVertices[2]], //triangle 3
    [octagonVertices[4], internalVertices[0], octagonVertices[3]], //triangle 4
    [octagonVertices[5], internalVertices[0], octagonVertices[4]], //triangle 5
    [internalVertices[1], internalVertices[0], octagonVertices[5]], //triangle 6
    [octagonVertices[6], internalVertices[1], octagonVertices[5]], //triangle 7
    [octagonVertices[7], internalVertices[1], octagonVertices[6]], //triangle 8
    [internalVertices[1], octagonVertices[7], internalVertices[0]], //triangle 9
    [internalVertices[0], octagonVertices[7], octagonVertices[0]]  //triangle 10
];

// Spread out triangle positions
const trianglePositions = [
    { x: -400, y: -150 }, // Position for triangle 1
    { x: -450, y: 200 },  // Position for triangle 2
    { x: 300, y: -200 },  // Position for triangle 3
    { x: 350, y: 100 },   // Position for triangle 4
    { x: -400, y: -450 }, // Position for triangle 5
    { x: 150, y: -450 },  // Position for triangle 6
    { x: -250, y: 100 },  // Position for triangle 7
    { x: 200, y: 150 },   // Position for triangle 8
    { x: 100, y: -450 },  // Position for triangle 9
    { x: 500, y: 300 }    // Position for triangle 10
];

// triangleTargets for the 'snapping' feature
const triangleTargets = [
    { x: 0, y: 0 }, // Target for triangle 1
    { x: 0, y: 0 }, // Target for triangle 2
    { x: 0, y: 0 }, // Target for triangle 3
    { x: 0, y: 0 }, // Target for triangle 4
    { x: 0, y: 0 }, // Target for triangle 5
    { x: 0, y: 0 }, // Target for triangle 6
    { x: 0, y: 0 }, // Target for triangle 7
    { x: 0, y: 0 }, // Target for triangle 8
    { x: 0, y: 0 }, // Target for triangle 9
    { x: 0, y: 0 }  // Target for triangle 10
];

function createTriangle(vertices) {
    const triangleShape = new THREE.Shape();
    triangleShape.moveTo(vertices[0].x, vertices[0].y);
    triangleShape.lineTo(vertices[1].x, vertices[1].y);
    triangleShape.lineTo(vertices[2].x, vertices[2].y);
    triangleShape.closePath();
    return triangleShape; 
}

const triangleMeshes = []; // array that hold triangle meshes

// Add triangles to the scene at predetermined positions
function addTrianglesToScene(triangles, positions) {
    triangles.forEach((vertices, index) => {
        const triangle = createTriangle(vertices); // create triangle shape
        const geometry = new THREE.ShapeGeometry(triangle);
        const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, side: THREE.DoubleSide }); // random color
        const mesh = new THREE.Mesh(geometry, material); // create mesh from geometry and material

        mesh.position.set(positions[index].x, positions[index].y, 0);
        mesh.targetPosition = new THREE.Vector3(triangleTargets[index].x, triangleTargets[index].y, 0); // Set target position for snapping later
        mesh.snapped = false; // Track if the triangle is snapped
        triangleMeshes.push(mesh); // push mesh into triangleMeshes array
        scene.add(mesh); // adds mesh to the scene
    });
}

// Function to create the octagon outline
function createOctagon() {
    const geometry = new THREE.BufferGeometry().setFromPoints(octagonVertices);
    const material = new THREE.LineBasicMaterial({ color: 0x000000 }); // color black
    const outlinedOctagon = new THREE.LineLoop(geometry, material); // uses LineLoop to draw the outline
    scene.add(outlinedOctagon); // adds octagon outline to the scene
}

createOctagon(); // calls the createOctagon function
addTrianglesToScene(predefinedTriangles, trianglePositions); // Use predefined triangles and their positions

// Handle mouse events for dragging
let selectedMesh = null;
let mousePosition = new THREE.Vector2();
let offset = new THREE.Vector3();

function onMouseDown(event) {
    mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
    mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mousePosition, camera);

    const intersects = raycaster.intersectObjects(triangleMeshes);
    if (intersects.length > 0) {
        selectedMesh = intersects[0].object;

        // Allow dragging only if not snapped
        if (!selectedMesh.snapped) {
            const intersectionPoint = intersects[0].point;
            offset.copy(selectedMesh.position).sub(intersectionPoint);
        } else {
            selectedMesh = null; // Don't select snapped triangles
        }
    }
}

function onMouseMove(event) {
    if (selectedMesh) {
        mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
        mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mousePosition, camera);
        const intersection = raycaster.intersectObject(selectedMesh);

        if (intersection.length > 0) {
            selectedMesh.position.copy(intersection[0].point).add(offset);
        }
    }
}

var click = new Audio('click.mp3'); //audio for when piece clicks in place

function onMouseUp() {
    if (selectedMesh) { // If a mesh is selected
        const targetPos = selectedMesh.targetPosition; // Get target position for snapping
        const distance = selectedMesh.position.distanceTo(targetPos); // Calculate distance to target position

        if (distance < 20) { // how close piece needs to be to snap
            selectedMesh.position.copy(targetPos); // Snap to target position
            selectedMesh.snapped = true; // Mark triangle as snapped
            click.play(); //plays click audio
            selectedMesh.material = new THREE.MeshBasicMaterial({color : 0x00ff00, side : THREE.DoubleSide });
        }
        selectedMesh = null;
    }
}

// add the mouse events to canvas
canvas.addEventListener('mousedown', onMouseDown);
canvas.addEventListener('mousemove', onMouseMove);
canvas.addEventListener('mouseup', onMouseUp);

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera); // renders the scene
}

animate(); // calls animate function
</script>
</body>
</html>
