<!DOCTYPE html>
<html>
<head>
    <title>CSC3210 Puzzle Pandamonium</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="1200" height=""></canvas>

<script type="module">
import * as THREE from 'three';

const canvas = document.getElementById('myCanvas');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 3000);
camera.position.z = 800;
camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
scene.add(camera);

const renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
renderer.setClearColor(0xFFFFFF);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

// Define vertices of the octagon
const octagonVertices = [
    new THREE.Vector2(-250, -125), //0
    new THREE.Vector2(-125, -250), //1
    new THREE.Vector2(125, -250), //2
    new THREE.Vector2(250, -125), //3
    new THREE.Vector2(250, 125), //4
    new THREE.Vector2(125, 250), //5
    new THREE.Vector2(-125, 250), //6
    new THREE.Vector2(-250, 125) //7
];

// Define internal vertices to ensure proper tiling
const internalVertices = [
    new THREE.Vector2(0,0),
    new THREE.Vector2(-50,175)
];

// Define triangles using octagon and internal vertices without overlaps
const predefinedTriangles = [
    [octagonVertices[1], internalVertices[0], octagonVertices[0]], //t1
    [octagonVertices[2], internalVertices[0], octagonVertices[1]], //t2
    [octagonVertices[3], internalVertices[0], octagonVertices[2]], //t3
    [octagonVertices[4], internalVertices[0], octagonVertices[3]], //t4
    [octagonVertices[5], internalVertices[0], octagonVertices[4]], //t5
    [internalVertices[1], internalVertices[0], octagonVertices[5]], //t6
    [octagonVertices[6], internalVertices[1], octagonVertices[5]], //t7
    [octagonVertices[7], internalVertices[1], octagonVertices[6]], //t8
    [internalVertices[1], octagonVertices[7], internalVertices[0]], //t9
    [internalVertices[0], octagonVertices[7], octagonVertices[0]] //t10
];

// Function to create triangles from predefined vertices
function createTriangle(vertices) {
    const triangleShape = new THREE.Shape();
    triangleShape.moveTo(vertices[0].x, vertices[0].y);
    triangleShape.lineTo(vertices[1].x, vertices[1].y);
    triangleShape.lineTo(vertices[2].x, vertices[2].y);
    triangleShape.closePath();
    
    return triangleShape;
}

const triangleMeshes = [];

// Add triangles to the scene
function addTrianglesToScene(triangles) {
    triangles.forEach((vertices) => {
        const triangle = createTriangle(vertices);
        const geometry = new THREE.ShapeGeometry(triangle);
        const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geometry, material);
        triangleMeshes.push(mesh);
        scene.add(mesh);
    });
}

// Function to create the octagon outline
function createOctagon() {
    const geometry = new THREE.BufferGeometry().setFromPoints(octagonVertices);
    const material = new THREE.LineBasicMaterial({ color: 0x000000 });
    const outlinedOctagon = new THREE.LineLoop(geometry, material);
    scene.add(outlinedOctagon);
}

createOctagon();
addTrianglesToScene(predefinedTriangles); // Use predefined triangles

// Handle mouse events for dragging
let selectedMesh = null;
let mousePosition = new THREE.Vector2();
let offset = new THREE.Vector3();

function onMouseDown(event) {
    mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
    mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mousePosition, camera);

    const intersects = raycaster.intersectObjects(triangleMeshes);
    if (intersects.length > 0) {
        selectedMesh = intersects[0].object;
        const intersectionPoint = intersects[0].point;
        offset.copy(selectedMesh.position).sub(intersectionPoint);
    }
}

function onMouseMove(event) {
    if (selectedMesh) {
        mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
        mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mousePosition, camera);
        const intersection = raycaster.intersectObject(selectedMesh);

        if (intersection.length > 0) {
            selectedMesh.position.copy(intersection[0].point).add(offset);
        }
    }
}

function onMouseUp() {
    if (selectedMesh) {
        selectedMesh = null;
    }
}

canvas.addEventListener('mousedown', onMouseDown);
canvas.addEventListener('mousemove', onMouseMove);
canvas.addEventListener('mouseup', onMouseUp);

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
